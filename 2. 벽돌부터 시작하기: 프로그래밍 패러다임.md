# 2. 벽돌부터 시작하기: 프로그래밍 패러다임

# 패러다임 개요
#### 구조적 프로그래밍
최초로 적용된 패러다임  
> 구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대해 규칙을 부과한다.

#### 객체지향 프로그래밍  
> 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

#### 함수형 프로그래밍
> 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

#### 결론
세 가지 패러다임과 아키텍쳐의 세 가지 큰 관심사가 어떻게 서로 연관되는지에 주목하자.
# 구조적 프로그래밍
구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.  
# 객체 지향 프로그래밍  
좋은 아키텍쳐를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.
> 그럼 객체 지향이란 무엇일까?

객체지향의 본질을 설명하기 위해 세 가지 주문에 기대는 부류도 있는데, 캡슐화, 상속, 다형성이 바로 그 주문이다.  
이들은 객체 지향이 세가지 개념을 적절하게 조합한 것이나 또는 객체지향 언어는 최소한 세 가지 요소를 반드시 지원해야 한다고 말한다.  

#### 캡슐화 
데이터와 함수를 쉽고 효과적으로 캡슐화 하는 방법을 객체 지향 언어가 제공한다.  
이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.  
객체 지향 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 구분 된다.  

#### 상속
객체 지향 언어는 상속만큼은 확실히 제공한다.  

#### 다형성
단순한 기법들이 모든 객체지향이 지닌 다형성의 근간이 된다. 
# 함수형 프로그래밍
#### 불변성과 아키텍처
우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 가변변수가 없다면 절대로 생기지 않는다.  
* 아키텍트라면 동시성 문제에 지대한 관심을 가져야한다.  
* 그리고 불변성이 정말로 실현 가능한지를 스스로에게 물어봐야한다.  

이 질문에 대한 대답은 긍정적이다.  
하지만 저정공간이 무한하고 프로세서의 속도가 무한히 빠르다는 전제에서 말이다.
* 불변성 실현을 가능하겠지면 일종의 타협을 해야한다. 

#### 가변성의 분리
불변성과 관련하여 가장 주요한 타협중 하나는  

* 애플리케이션, 또는 애플리캐이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
불변 컴포넌트에서는 순순하게 함수형 방식으로만 적업이 처리되며, 어떠한 가변 변수도 사용되지 않는다. 

불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 
![image](https://songii00.github.io/assets/images/post/191012/(27).png)  
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.  

#### 이벤트 소싱  
- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.  
<<<<<<< Updated upstream
=======

#### 결론
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
- 객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 부과되는 규율이다.
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구상된다.
>>>>>>> Stashed changes
