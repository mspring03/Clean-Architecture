# 3. 설계 원칙

좋은 소프트웨어 시스템은 깔끔한 코드로 부터 시작한다.  
좋은 벽돌로 좋은 아키텍처를 정의하는 원칙이 바로 ```SOLID```이다.  

```SOLID``` 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

그래서 ```SOLID``` 가 무엇인가

* SRP: 단일 책임 원칙  
  각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.  
  
* OCP: 개방-폐쇄 원칙  
  코드를 수정하기보다 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경 할 수 있다는 것이 이 원칙의 요지다.  
  
* LSP: 리스코프 치환 원칙  
  상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능하야 한다는 계약을 반드시 지켜야 한다.  
  
* ISP: 인터페이스 분리 원칙
  이 원칙에 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
  
* DIP: 의존성 역전의 원칙
  고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

  # SRP: 단일 책임 원칙
> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.  
단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.  
아마도 이 원칙을 이해하는 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는 것이다.

#### 징후 1: 우발적 중복
액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한다.  
SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

#### 징후 2: 병합
소스 파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생하리라고 짐작한다.  
메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 높아진다.  
이 문제를 벗어나는 방법은 서로 다른 액터를 뒷바침하는 코드를 서로 분리하는 것이다.

#### 해결책
이 문제의 해결책은 다양하다.  
그 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다.
가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다.  
* 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어 세 개의 클래스가 공유하도록 한다.
* 각 클래스는 자신의 메서드에 필요한 소스코드만 포함한다.
* 세 클래스는 서로의 존재를 몰라야 한다.
* 따라서 우연한 중복을 피할 수 있다.
  
반면 이 해결책은 개발자가 세 가지 클래스를 인스턴스화 하고 추적해야 한다는 게 단점이다.  
이러할때 흔히 쓰는 기법으로 ```퍼사드``` 패턴이 있다.  
![clipboard.png](MfoM0fflq-clipboard.png)
* EmployeeFacade에 코드는 거의 없다.
* 이 클래스는 세 클래스의 객체를 생성하고
* 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

어떤 개발자는 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다.  
이 경우라면 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되  
Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.  
![clipboard.png](bpyBljHGM-clipboard.png)
# OCP: 개방-폐쇠 원칙
> 소프트췌어 개체는 확장에 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

다시말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.  
* 소프트웨어 아키텍처를 공부하는 가장 근본적인 이유가 바로 이 때문이다.  
* 만약 요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면,
* 그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린 것이다.  

#### 사고실험
소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 최소화될 것이다.  
가장 이상적인 변경량은 0이다.  
* 서로다른 목적으로 변경되는 요소를 적절하게 분리하고 이들 요소 사이의 의존성을 체계화 함으로서 변경량을 최소화할 수 있다.  

책임을 분리했다면, 두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록 소스코드 의존성도 확실히 조직화해야 한다.  
또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다. 

![clipboard.png](raGMrRBbX-clipboard.png)
이러한 목적을 달성하려면 처리 과정을 클래스 단위로 분할하고,  
이들 클래스를 위 그림에서 이중선으로 표시한 컴포넌트 단위로 구분해야 한다.
* 화살표가 열려 있다면 사용 관계이다.
* 화살표가 닫혀 있다면 구현 관계 또는 상속 관계이다.  

여기서 주목할 점은 모든 의존성이 소스 코드 의존성을 나타낸다는 사실이다. 
* 화살표가 A 클래스에서 B 클래스로 향한다면,  
* A 클래스에서는 B 클래스를 호출하지만 B 클래스에서는 A 클래스를 전혀 호출하지 않음을 뜻한다.

또 다른 주목할점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다.  
![clipboard.png](21hcoTFti-clipboard.png)
A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.  

#### 방향서 제어  
2칸 위 그림에서 FinancialDataGateway 인터페이스는 FinancialReportDenerator와 FinancialDataMapper 사이에 위치하는데,  
이는 의존성을 역전시키기 위해서다.  
FinancialDataGateway 인터페이스가 없었다면 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다.  
FinancialReport Presenter 인터페이스와 2개의 view 인터페이스도 같은 목적을 가진다.

#### 정보 은닉  
FinanciaResportRequester 인터페이스는 방향성 제어와는 다른 목적을 가진다.  
이 인터페이스는 FinanciaResportRequester가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다.  
